#!/usr/bin/env python3
import os, sys, shutil, re, time, tempfile, signal, random, string, argparse
from datetime import datetime
from glob import glob
from enum import Enum, auto
from diopter.compiler import (
    CompilationSetting,
    CompilerExe,
    OptLevel,
    SourceProgram,
    Language,
    ObjectCompilationOutput
)
from diopter.sanitizer import Sanitizer
from diopter.utils import TempDirEnv
import subprocess as sp
from synthesizer.synthesizer import Synthesizer, SynthesizerError
from utils.compcert import CComp as this_CComp
from pathlib import Path
from datetime import datetime
from termcolor import colored
import tempfile

def print_red(msg):
    print(colored(datetime.now().strftime("%Y-%m-%d %H:%M:%S") + ' >', 'yellow'), colored(msg, 'red'), flush=True)
def print_green(msg):
    print(colored(datetime.now().strftime("%Y-%m-%d %H:%M:%S") + ' >', 'yellow'), colored(msg, 'green'), flush=True)
def print_blue(msg):
    print(colored(datetime.now().strftime("%Y-%m-%d %H:%M:%S") + ' >', 'yellow'), colored(msg, 'blue'), flush=True)

def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
    return ''.join(random.choice(chars) for _ in range(size))


DEBUG = 0
"""CONFIG"""
FUNCTION_DB_FILE = os.path.join(os.path.dirname(__file__), './databaseconstructor/functions_pointer_global_io.json')
MIN_PROGRAM_SIZE = 8000 # programs shorter than this many bytes are too boring to test
NUM_MUTANTS = 10 # number of mutants generated by the synthesizer per seed.
COMPILER_TIMEOUT = 200
PROG_TIMEOUT = 10
CCOMP_TIMEOUT = 60 # compcert timeout
CSMITH_USER_OPTIONS = "--no-volatiles --no-volatile-pointers --no-unions"
CSMITH_TIMEOUT = 20
YARPGEN_USER_OPTIONS = "--std=c --allow-ub-in-dc=some --allow-dead-data=true"
YARPGEN_TIMEOUT = 20
CREDUCE_JOBS = 1
"""TOOL"""
USE_YARPGEN = False
CSMITH_HOME = os.environ["CSMITH_HOME"]
YARPGEN_HOME = os.environ["YARPGEN_HOME"]

CC = CompilationSetting(
            compiler=CompilerExe.get_system_gcc(),
            opt_level=OptLevel.O3,
            flags=("-march=native",)
            )
SAN_SAN = Sanitizer(checked_warnings=False, use_ccomp_if_available=False) # sanitizers only
SAN_CCOMP = this_CComp.get_system_ccomp() # CompCert only

"""Global vars"""

class CompCode(Enum):
    """Compile status
    """
    OK      =   auto()  # ok
    Timeout =   auto()  # timeout during compilation
    Sanfail =   auto()  # sanitization failed
    Crash   =   auto()  # compiler crash
    Error   =   auto()  # compiler error
    WrongEval=  auto()  # inconsistent results across compilers but consistent within the same compiler
    Wrong   =   auto()  # inconsistent results across compilers/opts

def generate_random_string(len:int=5) -> str:
    """Generate a random string of length len"""
    return ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(len))

def run_cmd(cmd, timeout):
    if type(cmd) is not list:
        cmd = cmd.split(' ')
        cmd = list(filter(lambda x: x!='', cmd))
    # Start the subprocess
    process = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE)
    # Wait for the subprocess to finish or timeout
    try:
        output, error = process.communicate(timeout=timeout)
        output = output.decode("utf-8")
    except sp.TimeoutExpired:
        # Timeout occurred, kill the process
        try:
            os.killpg(process.pid, signal.SIGTERM)
        except ProcessLookupError:
            pass
        finally:
            output = ''
        # A workaround to tmpxxx.exe as it sometimes escapes from os.killpg
        cmd_str = " ".join(cmd)
        time.sleep(2)
        if '.exe' in cmd_str:
            os.system(f"pkill -9 -f {cmd_str}")
        return 124, output

    # Return the exit code and stdout of the process
    return process.returncode, output

def write_bug_desc_to_file(to_file, data):
    with open(to_file, "a") as f:
        f.write(f"/* {data} */\n")

def read_checksum(data):
    res = re.findall(r'checksum = (.*)', data)
    if len(res) > 0:
        return res[0]
    return 'NO_CKSUM'

def check_sanitizers(src):
    """Check validity with sanitizers"""
    with open(src, 'r') as f:
        code = f.read()
    prog = SourceProgram(code=code, language=Language.C)
    preprog = CC.preprocess_program(prog, make_compiler_agnostic=True)
    if DEBUG:
        print(datetime.now().strftime("%d/%m/%Y %H:%M:%S"), "SAN.sanitize", flush=True)
    if not SAN_SAN.sanitize(preprog):
        return False
    return True

def check_ccomp(src, random_count=1):
    """
    Check validity with CompCert.
    src:str -> source file
    random_count:int -> the number of times using ccomp -random for checking
    """
    with open(src, 'r') as f:
        code = f.read()
    prog = SourceProgram(code=code, language=Language.C)
    preprog = CC.preprocess_program(prog, make_compiler_agnostic=True)
    if DEBUG:
        print(datetime.now().strftime("%d/%m/%Y %H:%M:%S"), "SAN.ccomp", flush=True)
    with TempDirEnv():
        try:
            ccomp_result = SAN_CCOMP.check_program(preprog, timeout=CCOMP_TIMEOUT, debug=DEBUG)
        except sp.TimeoutExpired:
            return False
        if ccomp_result is False:
            return False
    with TempDirEnv():
        for _ in range(random_count):
            try:
                ccomp_result_random = SAN_CCOMP.check_program(preprog, timeout=CCOMP_TIMEOUT, debug=DEBUG, additional_flags=["-random"])
            except sp.TimeoutExpired:
                return False
            if ccomp_result_random is False:
                return False
            # check for unspecified behavior
            if ccomp_result.stdout != ccomp_result_random.stdout:
                return False
    return True

def compile_and_run(compiler, src):
    cksum = ''
    tmp_f = tempfile.NamedTemporaryFile(suffix=".exe", delete=False)
    tmp_f.close()
    exe = tmp_f.name
    if USE_YARPGEN:
        cmd = f"{compiler} {src} -o {exe}"
    else:
        cmd = f"{compiler} {src} -I{CSMITH_HOME}/include -o {exe}"
    ret, out = run_cmd(cmd, COMPILER_TIMEOUT)
    if ret == 124: # another compile chance when timeout
        time.sleep(1)
        ret, out = run_cmd(cmd, COMPILER_TIMEOUT)
    if ret == 124: # we treat timeout as crash now.
        write_bug_desc_to_file(src, f"Compiler timeout! Can't compile with {compiler}")
        if os.path.exists(exe): os.remove(exe)
        return CompCode.Timeout, cksum
    if ret != 0:
        write_bug_desc_to_file(src, f"Compiler crash! Can't compile with {compiler}")
        if os.path.exists(exe): os.remove(exe)
        return CompCode.Crash, cksum
    ret, out = run_cmd(f"{exe}", PROG_TIMEOUT)
    cksum = read_checksum(out)
    write_bug_desc_to_file(src, f"EXITof {compiler}: {ret}")
    write_bug_desc_to_file(src, f"CKSMof {compiler}: {cksum}")
    if os.path.exists(exe): os.remove(exe)
    return CompCode.OK, cksum

def check_compile(src:str, compilers:list) -> CompCode:
    """Compile the program with a list of compilers and check their status
    """
    cksum_list = []
    for comp in compilers:
        if DEBUG:
            print(datetime.now().strftime("%d/%m/%Y %H:%M:%S"), "compiler_and_run: ", comp, flush=True)
        ret, cksum = compile_and_run(comp, src)
        if ret == CompCode.Crash:
            return CompCode.Crash
        if ret == CompCode.Timeout:
            return CompCode.Timeout
        if ret != CompCode.OK:
            return CompCode.Error
        cksum_list.append(cksum)
    if len(cksum_list) != len(compilers) or len(set(cksum_list)) != 1:
        maybe_WrongEval = True
        for i in range(len(compilers)):
            for j in range(i+1, len(compilers)):
                if compilers[i].split(' ')[0] == compilers[j].split(' ')[0] and cksum_list[i] != cksum_list[j]:
                    maybe_WrongEval = False
        if maybe_WrongEval:
            return CompCode.WrongEval
        return CompCode.Wrong
    return CompCode.OK

def csmith_one(src: str):
    print_blue('Generating seed by Csmith...')
    while True:
        cmd = f"{CSMITH_HOME}/bin/csmith {CSMITH_USER_OPTIONS} --output {src}"
        ret, out = run_cmd(cmd, CSMITH_TIMEOUT)
        if ret != 0:
            print("csmith failed: generation.")
            continue
        # check size
        if os.path.getsize(src) < MIN_PROGRAM_SIZE:
            print("csmith failed: small program.")
            continue
        # check sanitization
        if check_sanitizers(src) and check_ccomp(src):
            break
        print("csmith failed: sanitization.")
    return

# YARPGen followed GCC's tips to define min/max.
# However the usage of statement expression is not supported
# by CompCert, making us unable to validate it.
YARPGEN_CCOMP_INCOMPATIBLE_MINMAX = """\
#define max(a,b) \\
    ({ __typeof__ (a) _a = (a); \\
       __typeof__ (b) _b = (b); \\
       _a > _b ? _a : _b; })
#define min(a,b) \\
    ({ __typeof__ (a) _a = (a); \\
       __typeof__ (b) _b = (b); \\
       _a < _b ? _a : _b; })
"""

# We leverage C11's _Generic to implement the same functionality
# We did not use #define min(a,b) (a) < (b) ? (a) : (b) because
# there'll be unintended behaviors for example min(x++,y++).
YARPGEN_CCOMP_COMPATIBLE_MINMAX = """
char min_char(char x, char y) { return x < y ? x : y; }
char max_char(char x, char y) { return x > y ? x : y; }

signed char min_schar(signed char x, signed char y) { return x < y ? x : y; }
signed char max_schar(signed char x, signed char y) { return x > y ? x : y; }

unsigned char min_uchar(unsigned char x, unsigned char y) { return x < y ? x : y; }
unsigned char max_uchar(unsigned char x, unsigned char y) { return x > y ? x : y; }

short min_short(short x, short y) { return x < y ? x : y; }
short max_short(short x, short y) { return x > y ? x : y; }

unsigned short min_ushort(unsigned short x, unsigned short y) { return x < y ? x : y; }
unsigned short max_ushort(unsigned short x, unsigned short y) { return x > y ? x : y; }

int min_int(int x, int y) { return x < y ? x : y; }
int max_int(int x, int y) { return x > y ? x : y; }

unsigned int min_uint(unsigned int x, unsigned int y) { return x < y ? x : y; }
unsigned int max_uint(unsigned int x, unsigned int y) { return x > y ? x : y; }

long min_long(long x, long y) { return x < y ? x : y; }
long max_long(long x, long y) { return x > y ? x : y; }

unsigned long min_ulong(unsigned long x, unsigned long y) { return x < y ? x : y; }
unsigned long max_ulong(unsigned long x, unsigned long y) { return x > y ? x : y; }

long long min_llong(long long x, long long y) { return x < y ? x : y; }
long long max_llong(long long x, long long y) { return x > y ? x : y; }

unsigned long long min_ullong(unsigned long long x, unsigned long long y) { return x < y ? x : y; }
unsigned long long max_ullong(unsigned long long x, unsigned long long y) { return x > y ? x : y; }

float min_float(float x, float y) { return x < y ? x : y; }
float max_float(float x, float y) { return x > y ? x : y; }

double min_double(double x, double y) { return x < y ? x : y; }
double max_double(double x, double y) { return x > y ? x : y; }

long double min_ldouble(long double x, long double y) { return x < y ? x : y; }
long double max_ldouble(long double x, long double y) { return x > y ? x : y; }

#define min(x, y) _Generic((x), \\
    char: min_char, \\
    signed char: min_schar, \\
    unsigned char: min_uchar, \\
    short: min_short, \\
    unsigned short: min_ushort, \\
    int: min_int, \\
    unsigned int: min_uint, \\
    long: min_long, \\
    unsigned long: min_ulong, \\
    long long: min_llong, \\
    unsigned long long: min_ullong, \\
    float: min_float, \\
    double: min_double, \\
    long double: min_ldouble, \\
    default: min_int \\
)(x, y)

#define max(x, y) _Generic((x), \\
    char: max_char, \\
    signed char: max_schar, \\
    unsigned char: max_uchar, \\
    short: max_short, \\
    unsigned short: max_ushort, \\
    int: max_int, \\
    unsigned int: max_uint, \\
    long: max_long, \\
    unsigned long: max_ulong, \\
    long long: max_llong, \\
    unsigned long long: max_ullong, \\
    float: max_float, \\
    double: max_double, \\
    long double: max_ldouble, \\
    default: max_int \\
)(x, y)

"""


def yarpgen_one(src: str):
    print_blue('Generating seed by YARPGen...')
    tmpdir = tempfile.mkdtemp(prefix=f"yarpgen-", dir=tempfile.gettempdir())
    while True:
        cmd = f"{YARPGEN_HOME}/yarpgen {YARPGEN_USER_OPTIONS} --out-dir={tmpdir}"
        ret, out = run_cmd(cmd, YARPGEN_TIMEOUT)
        if ret != 0:
            print(f"yarpgen failed: generation.")
            continue
        # merge all files into a single seed.c
        # our profiler also requires us to put the main() in the very end
        tmp_path = Path(tmpdir)
        driv_file = tmp_path / "driver.c"
        if not driv_file.exists():
            print("yarpgen failed: driver.c not found in the generated output.")
            continue
        driv_cont = driv_file.read_text().splitlines()
        forw_decl_index = -1
        for index, line in enumerate(driv_cont):
            if line.startswith('void test(') and line.endswith(');'):
                forw_decl_index = index
                break
        if forw_decl_index == -1:
            print("yarpgen failed: the forward declaration of the test function is not found.")
            continue
        fun_file = tmp_path / "func.c"
        if not fun_file.exists():
            print("yarpgen failed: func.c not found in the generated output.")
            continue
        with open(src, "w") as fou:
            fou.write("\n".join(driv_cont[:forw_decl_index]))
            fou.write("\n\n")
            # Replace the init header as it only declares extern variables
            # that are defined in the driver file. Also, replace the min/max
            # macro definition with ours as ccomp doesn't support statement expression
            fou.write(fun_file.read_text().replace("#include \"init.h\"", "").replace(YARPGEN_CCOMP_INCOMPATIBLE_MINMAX, YARPGEN_CCOMP_COMPATIBLE_MINMAX))
            fou.write("\n".join(driv_cont[forw_decl_index+1:]))
        # check sanitization
        if check_sanitizers(src) and check_ccomp(src):
            break
        print("yarpgen failed: sanitization.")
    shutil.rmtree(tmpdir)
    return

def run_one(compilers:list[str], dst_dir:Path, SYNER:Synthesizer) -> Path | None:
    """Run compiler testing
    """
    save_realsmith_dir = (dst_dir)
    succ_file_id = id_generator()
    src = str((dst_dir / f'{succ_file_id}_seed.c').absolute())
    if USE_YARPGEN:
        yarpgen_one(src)
    else:
        csmith_one(src)
    print_blue(f"Seed generated: {src}")
    ret = check_compile(src, compilers)
    print_blue('Synthesizing mutants...')
    # synthesize
    try:
        syn_files = SYNER.synthesizer(src_filename=src, num_mutant=NUM_MUTANTS, use_yarpgen=USE_YARPGEN, DEBUG=DEBUG)
    except Exception as e:
        print('SynthesizerError:', e if e else '<no-output>')
        os.remove(src)
        return 0

    print_green(f'Synthesizing done! Programs saved as {src.replace(".c", "_syn*.c")}')

    return 0


if __name__=='__main__':
    import time

    parser = argparse.ArgumentParser(description="Generate a number of realsmith mutants for evaluation.")
    parser.add_argument("--dst", required=True, type=Path, help="Destination directory for generated seeds.")
    parser.add_argument("--syn-prob", required=True, type=int, help="Synthesis probability")
    parser.add_argument("--num-mutants", required=True, type=int, help="The number of mutants per seed by realsmith")
    parser.add_argument("--func-db", default=FUNCTION_DB_FILE, type=str, help="Path to the functiondb file")
    parser.add_argument("--rand-seed", default=time.time_ns(), type=int, help="Randomness seed")
    parser.add_argument("--yarpgen", default=False, action='store_true', help="Replace Csmith with YARPGen")
    parser.add_argument("--verbose", default=False, action='store_true', help="Verbose or not")
    args = parser.parse_args()

    dst_dir = Path(args.dst)
    dst_dir.mkdir(parents=True, exist_ok=True)

    NUM_MUTANTS = args.num_mutants
    DEBUG = 1 if args.verbose else 0

    USE_YARPGEN = args.yarpgen
    if USE_YARPGEN:
        if not os.path.exists(os.path.join(YARPGEN_HOME, 'yarpgen')):
            print_red('YARPGEN_HOME is not set correctly, cannot find the yarpgen binary in "$YARPGEN_HOME/".')
            sys.exit(1)
        CC = CompilationSetting(
            compiler=CC.compiler,
            opt_level=CC.opt_level,
            flags=CC.flags + ("-mcmodel=large",),
            include_paths=CC.include_paths,
            system_include_paths=CC.system_include_paths,
            macro_definitions=CC.macro_definitions
        )
    else:
        if not os.path.exists(os.path.join(CSMITH_HOME, 'include/csmith.h')):
            print_red('CSMITH_HOME is not set correctly, cannot find csmith.h in "$CSMITH_HOME/include/".')
            sys.exit(1)
        CC = CompilationSetting(
            compiler=CC.compiler,
            opt_level=CC.opt_level,
            flags=CC.flags,
            include_paths=CC.include_paths + (f"{CSMITH_HOME}/include",),
            system_include_paths=CC.system_include_paths,
            macro_definitions=CC.macro_definitions
        )

    if not os.path.exists(args.func_db):
        print(f"File {args.func_db} does not exist!")
        parser.print_help()
        exit(1)

    random.seed(args.rand_seed)

    compilers = [
        "gcc -O0",
        "clang -O0"
    ]
    SYNER = Synthesizer(func_database=args.func_db, prob=args.syn_prob)
    with TempDirEnv() as tmp_dir:
        os.environ['TMPDIR'] = tmp_dir.absolute().as_posix()
        total = 0
        ret = run_one(compilers, dst_dir, SYNER)
